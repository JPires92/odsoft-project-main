pipeline {
    agent any

    environment {
        // Variáveis de ambiente para o pipeline
        PROJECT_NAME = "LMS"
        GITHUB_REPO_URL = "git@github.com:JPires1992/odsoft-project.git"
        GITHUB_REPO_CREDENTIALS = credentials('Pass_Github')
        NVD_API_KEY = credentials('NVD_API_KEY') //ID da credencial criada no Jenkins para as vulnerabilidades
        SERVER_PORT = "8081"
        DEPLOY_DIR="../deploy" // Diretório de deploy, raiz do workspace
    }

    stages {
        
        stage('Clean target directory') {
            steps {
                // Limpa o diretório target
                echo 'Cleaning target directory'
                sh 'mvn clean'
            }
        }

        stage('Package') {
            steps {
                // Empacota o projeto sem executar os testes novamente
                echo 'Packaging the project'
                sh 'mvn package -DskipUnitTests=true '
            }
        }

        stage('Deploy Application') {
            steps {
                // Mata o processo se estiver em execução, copia o novo arquivo JAR para a pasta de deploy e inicia a aplicação
                echo 'Kill the application if it is running'
                
                sh '''
                    # Obtem o PID do processo
                    process=$(netstat -aon | grep :$SERVER_PORT | awk '{print $5}' | head -n 1)
                    
                    # Verifica se o processo foi encontrado e termina o processo
                    if [ -n "$process" ]; then
                        echo "Killing process with PID: $process"
                        taskkill //PID $process //F
                    else
                        echo "No process found running in port $SERVER_PORT"
                    fi
                '''

                echo 'Deploying the application'
                sh '''                    
                    # Cria a pasta de deploy se não existir
                    mkdir -p $DEPLOY_DIR
                    
                    # Verifica se o arquivo JAR existe na pasta target
                    if [ -f "target/psoft-g1-0.0.1-SNAPSHOT.jar" ]; then
                        
                        # Se o JAR já existir na pasta de deploy, apaga-o
                        if [ -f "$DEPLOY_DIR/psoft-g1-0.0.1-SNAPSHOT.jar" ]; then
                            echo "Removing existing JAR in deploy directory..."
                            rm "$DEPLOY_DIR/psoft-g1-0.0.1-SNAPSHOT.jar"
                        fi
                        
                        # Copia o novo arquivo JAR para a pasta de deploy
                        cp target/psoft-g1-0.0.1-SNAPSHOT.jar $DEPLOY_DIR/
                        
                        # Muda para a pasta de deploy
                        cd $DEPLOY_DIR
                        
                        echo "Starting the application..."
                        
                        # Inicia a aplicação em segundo plano a partir da pasta de deploy
                        
                        echo "Application started in background on port $SERVER_PORT"
                    else
                        echo "Error: psoft-g1-0.0.1-SNAPSHOT.jar not found in target!"
                        exit 1
                    fi
                '''

                sh '''
                    cd $DEPLOY_DIR
                    nohup javaw -jar psoft-g1-0.0.1-SNAPSHOT.jar --server.port="$SERVER_PORT"
                    disown
                '''
            }
        }

        stage('Post-Analysis') {
            steps {
                
                //Publica o relatório de cobertura de testes do JaCoCo
                echo 'Publishing JaCoCo report'
                jacoco execPattern: 'target/jacoco.exec', classPattern: 'target/classes', sourcePattern: 'src/main/java', inclusionPattern: '**/*.class', exclusionPattern: ''

                //Arquiva relatório de testes de mutação
                archiveArtifacts artifacts: '**/target/pit-reports/**/mutations.xml', allowEmptyArchive: true
                // Publica o relatório de cobertura de mutação do Pitest
                pitmutation mutationStatsFile: '**/target/pit-reports/**/mutations.xml'

                //Arquiva o relatório de dependências
                archiveArtifacts artifacts: '**/dependency-check-report.xml', allowEmptyArchive: true
                // Publish the Dependency-Check report
                dependencyCheckPublisher pattern: '**/dependency-check-report.xml'

                //Arquiva o relatório de PMD
                archiveArtifacts artifacts: '**/target/pmd.xml', allowEmptyArchive: true
                // Publica o relatório do PMD
                recordIssues tools: [pmdParser(pattern: '**/target/pmd.xml')]

                // Limpa o workspace
                cleanWs()

            }
        }
    }
    
    post {
        always {
            echo "Pipeline completed."
        }
        success {
            echo 'Pipeline succeeded!'
        }
        failure {
            echo 'Pipeline failed!'
        }
    }
}